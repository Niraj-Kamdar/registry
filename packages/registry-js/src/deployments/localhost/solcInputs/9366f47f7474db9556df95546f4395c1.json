{
  "language": "Solidity",
  "sources": {
    "contracts/versioning/registrar/Registrar.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"../registry/VersionResolver.sol\";\nimport \"../registry/Registry.sol\";\nimport \"../VotingMachine.sol\";\n\nabstract contract Registrar is OwnableUpgradeable {\n  event ManagerAdded(bytes32 indexed packageId, address indexed manager);\n  event ManagerRemoved(bytes32 indexed packageId, address indexed manager);\n\n  address public registry;\n  address public votingMachine;\n\n  mapping(bytes32 => bool) public managers;\n\n  constructor(address _registry) {\n    initialize(_registry);\n  }\n\n  function initialize(address _registry) public initializer {\n    __Ownable_init();\n\n    registry = _registry;\n  }\n\n  function updateRegistry(address _registry) public onlyOwner {\n    registry = _registry;\n  }\n\n  function updateVotingMachine(address _votingMachine) public onlyOwner {\n    votingMachine = _votingMachine;\n  }\n\n  function addManager(bytes32 packageId, address manager)\n    public\n    packageOwner(packageId)\n  {\n    bytes32 key = keccak256(abi.encodePacked(packageId, manager));\n\n    managers[key] = true;\n\n    emit ManagerAdded(packageId, manager);\n  }\n\n  function removeManager(bytes32 packageId, address manager)\n    public\n    packageOwner(packageId)\n  {\n    bytes32 key = keccak256(abi.encodePacked(packageId, manager));\n\n    managers[key] = false;\n\n    emit ManagerRemoved(packageId, manager);\n  }\n\n  function proposeVersion(\n    bytes32 packageId,\n    uint256 majorVersion,\n    uint256 minorVersion,\n    uint256 patchVersion,\n    string calldata packageLocation\n  ) public {\n    VotingMachine votingMachineContract = VotingMachine(votingMachine);\n\n    votingMachineContract.proposeVersion(\n      packageId,\n      majorVersion,\n      minorVersion,\n      patchVersion,\n      packageLocation,\n      msg.sender\n    );\n  }\n\n  function isAuthorized(bytes32 packageId, address ownerOrManager)\n    public\n    view\n    returns (bool)\n  {\n    bytes32 key = keccak256(abi.encodePacked(packageId, ownerOrManager));\n\n    if (managers[key]) {\n      return true;\n    }\n\n    return getPackageOwner(packageId) == ownerOrManager;\n  }\n\n  modifier authorized(bytes32 packageId) {\n    require(\n      isAuthorized(packageId, msg.sender),\n      \"You do not have access to this package\"\n    );\n    _;\n  }\n\n  modifier packageOwner(bytes32 packageId) {\n    require(\n      getPackageOwner(packageId) == msg.sender,\n      \"You do not have access to the domain of this package\"\n    );\n    _;\n  }\n\n  function getPackageOwner(bytes32 packageId) private view returns (address) {\n    return Registry(registry).getPackageOwner(packageId);\n  }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal initializer {\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal initializer {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/versioning/registry/VersionResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./Registry.sol\";\n\nabstract contract VersionResolver is Registry {\n  function resolveToLeaf(bytes32 versionNodeId) public view returns (bytes32) {\n    PackageVersion storage versionNode = versionNodes[versionNodeId];\n    require(versionNode.created, \"Invalid Node\");\n\n    if (versionNode.leaf) {\n      return versionNodeId;\n    }\n\n    bytes32 latestNodeId = keccak256(\n      abi.encodePacked(versionNodeId, versionNode.latestSubVersion)\n    );\n\n    return resolveToLeaf(latestNodeId);\n  }\n\n  function getPackageLocation(bytes32 versionNodeId)\n    public\n    view\n    returns (string memory)\n  {\n    bytes32 concreteVersionId = resolveToLeaf(versionNodeId);\n    return versionNodes[concreteVersionId].location;\n  }\n\n  function getLatestVersionInfo(bytes32 packageId)\n    public\n    view\n    returns (\n      uint256 majorVersion,\n      uint256 minorVersion,\n      uint256 patchVersion,\n      string memory location\n    )\n  {\n    PackageVersion storage packageNode = versionNodes[packageId];\n    uint256 majorVersion = packageNode.latestSubVersion;\n    bytes32 majorNodeId = keccak256(abi.encodePacked(packageId, majorVersion));\n\n    PackageVersion storage majorNode = versionNodes[majorNodeId];\n    uint256 minorVersion = majorNode.latestSubVersion;\n    bytes32 minorNodeId = keccak256(\n      abi.encodePacked(majorNodeId, minorVersion)\n    );\n\n    PackageVersion storage minorNode = versionNodes[minorNodeId];\n    uint256 patchVersion = minorNode.latestSubVersion;\n    bytes32 patchNodeId = keccak256(\n      abi.encodePacked(minorNodeId, patchVersion)\n    );\n\n    PackageVersion storage patchNode = versionNodes[patchNodeId];\n    string memory location = patchNode.location;\n\n    return (majorVersion, minorVersion, patchVersion, location);\n  }\n}\n"
    },
    "contracts/versioning/registry/Registry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nabstract contract Registry is OwnableUpgradeable {\n  event OwnershipUpdated(\n    bytes32 indexed domainRegistryNode,\n    bytes32 packageId,\n    bytes32 domainRegistry,\n    address indexed owner\n  );\n\n  event VersionPublished(\n    bytes32 indexed packageId,\n    uint256 major,\n    uint256 minor,\n    uint256 patch,\n    string location\n  );\n\n  struct PackageVersion {\n    bool leaf;\n    uint256 latestSubVersion;\n    bool created;\n    string location; // empty on non-leaf nodes\n  }\n\n  struct PackageInfo {\n    address owner;\n    bytes32 domainRegistryNode;\n    bytes32 domainRegistry;\n  }\n\n  mapping(bytes32 => PackageVersion) public versionNodes;\n  mapping(bytes32 => PackageInfo) public packages;\n  address public ownershipUpdater;\n  address public versionPublisher;\n\n  constructor() {\n    initialize();\n  }\n\n  function initialize() public initializer {\n    __Ownable_init();\n  }\n\n  function updateOwnershipUpdater(address _ownershipUpdater) public onlyOwner {\n    ownershipUpdater = _ownershipUpdater;\n  }\n\n  function updateVersionPublisher(address _versionPublisher) public onlyOwner {\n    versionPublisher = _versionPublisher;\n  }\n\n  function updateOwnership(\n    bytes32 domainRegistry,\n    bytes32 domainRegistryNode,\n    address domainOwner\n  ) public {\n    assert(msg.sender == ownershipUpdater);\n\n    bytes32 packageId = keccak256(\n      abi.encodePacked(\n        keccak256(abi.encodePacked(domainRegistryNode)),\n        domainRegistry\n      )\n    );\n\n    packages[packageId] = PackageInfo(\n      domainOwner,\n      domainRegistryNode,\n      domainRegistry\n    );\n\n    emit OwnershipUpdated(\n      domainRegistryNode,\n      packageId,\n      domainRegistry,\n      domainOwner\n    );\n  }\n\n  function publishVersion(\n    bytes32 packageId,\n    uint256 majorVersion,\n    uint256 minorVersion,\n    uint256 patchVersion,\n    string memory location\n  ) public returns (bytes32) {\n    assert(msg.sender == versionPublisher);\n\n    bytes32 majorNodeId = keccak256(abi.encodePacked(packageId, majorVersion));\n    bytes32 minorNodeId = keccak256(\n      abi.encodePacked(majorNodeId, minorVersion)\n    );\n    bytes32 patchNodeId = keccak256(\n      abi.encodePacked(minorNodeId, patchVersion)\n    );\n\n    PackageVersion storage packageNode = versionNodes[packageId];\n    PackageVersion storage majorNode = versionNodes[majorNodeId];\n    PackageVersion storage minorNode = versionNodes[minorNodeId];\n\n    if (packageNode.latestSubVersion < majorVersion) {\n      packageNode.latestSubVersion = majorVersion;\n    }\n    packageNode.created = true;\n\n    if (majorNode.latestSubVersion < minorVersion) {\n      majorNode.latestSubVersion = minorVersion;\n    }\n    majorNode.created = true;\n\n    if (minorNode.latestSubVersion < patchVersion) {\n      minorNode.latestSubVersion = patchVersion;\n    }\n    minorNode.created = true;\n\n    require(!versionNodes[patchNodeId].created, \"Version is already published\");\n\n    versionNodes[patchNodeId] = PackageVersion(true, 0, true, location);\n\n    emit VersionPublished(\n      packageId,\n      majorVersion,\n      minorVersion,\n      patchVersion,\n      location\n    );\n\n    return patchNodeId;\n  }\n\n  function getPackageOwner(bytes32 packageId) public view returns (address) {\n    return packages[packageId].owner;\n  }\n}\n"
    },
    "contracts/versioning/VotingMachine.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"./version-events-listeners/IVersionVerifiedListener.sol\";\n\ncontract VotingMachine is OwnableUpgradeable {\n  event VersionProposed(\n    bytes32 indexed packageId,\n    bytes32 patchNodeId,\n    uint256 majorVersion,\n    uint256 minorVersion,\n    uint256 patchVersion,\n    string packageLocation,\n    address proposer\n  );\n\n  event VersionVotingStarted(\n    bytes32 indexed packageId,\n    bytes32 indexed patchNodeId,\n    uint256 majorVersion,\n    uint256 minorVersion,\n    uint256 patchVersion,\n    string packageLocation,\n    address proposer,\n    bool isPatch\n  );\n\n  event VersionVote(\n    address indexed verifier,\n    bytes32 indexed patchNodeId,\n    bytes32 packageLocationHash,\n    bool approved\n  );\n\n  event VersionDecided(\n    bytes32 indexed patchNodeId,\n    bool indexed verified,\n    bytes32 packageLocationHash\n  );\n\n  struct ProposedVersion {\n    address[] approvingVerifiers;\n    address[] rejectingVerifiers;\n    mapping(address => bool) votedVerifiers;\n    bool decided;\n    bool verified;\n    bool votingStarted;\n    bytes32 packageId;\n    bytes32 majorNodeId;\n    bytes32 minorNodeId;\n    bytes32 patchNodeId;\n    string packageLocation;\n    uint256 majorVersion;\n    uint256 minorVersion;\n    uint256 patchVersion;\n    address proposer;\n  }\n\n  struct QueuedVersion {\n    bytes32 nextQueuedVersionId;\n    bytes32 patchNodeId;\n  }\n\n  struct MajorVersionQueueContainer {\n    bytes32 headVersionId;\n    bytes32 tailVersionId;\n    mapping(bytes32 => QueuedVersion) queuedVersions;\n  }\n\n  struct VerifiedMajorVersion {\n    bytes32 lowestMinorNodeId;\n  }\n\n  struct VerifiedMinorVersion {\n    uint256 versionNumber;\n    bytes32 nextMinorNodeId;\n    bytes32 prevMinorNodeId;\n    bytes32 majorNodeId;\n    bytes32 patchNodeId;\n  }\n\n  struct Vote {\n    bytes32 patchNodeId;\n    bytes32 prevMinorNodeId;\n    bytes32 nextMinorNodeId;\n    bool approved;\n  }\n\n  address public registrar;\n  address public versionVerifiedListener;\n\n  mapping(bytes32 => MajorVersionQueueContainer)\n    public majorVersionQueueContainers;\n  mapping(bytes32 => ProposedVersion) public proposedVersions;\n  mapping(bytes32 => VerifiedMinorVersion) public verifiedMinorVersions;\n  mapping(bytes32 => VerifiedMajorVersion) public verifiedMajorVersions;\n\n  mapping(address => bool) public authorizedVerifiers;\n  uint256 public authorizedVerifierCount;\n\n  constructor(address _registrar) {\n    initialize(_registrar);\n  }\n\n  function initialize(address _registrar) public initializer {\n    __Ownable_init();\n\n    registrar = _registrar;\n  }\n\n  function updateRegistrar(address _registrar) public onlyOwner {\n    registrar = _registrar;\n  }\n\n  function updateVersionVerifiedListener(address _versionVerifiedListener)\n    public\n    onlyOwner\n  {\n    versionVerifiedListener = _versionVerifiedListener;\n  }\n\n  function authorizeVerifiers(address[] memory addresses) public onlyOwner {\n    for (uint256 i = 0; i < addresses.length; i++) {\n      if (!authorizedVerifiers[addresses[i]]) {\n        authorizedVerifiers[addresses[i]] = true;\n        authorizedVerifierCount++;\n      }\n    }\n  }\n\n  function unauthorizeVerifiers(address[] memory addresses) public onlyOwner {\n    for (uint256 i = 0; i < addresses.length; i++) {\n      if (authorizedVerifiers[addresses[i]]) {\n        authorizedVerifiers[addresses[i]] = false;\n        authorizedVerifierCount--;\n      }\n    }\n  }\n\n  function proposeVersion(\n    bytes32 packageId,\n    uint256 majorVersion,\n    uint256 minorVersion,\n    uint256 patchVersion,\n    string calldata packageLocation,\n    address proposer\n  ) public {\n    assert(msg.sender == registrar);\n\n    bytes32 majorNodeId = keccak256(abi.encodePacked(packageId, majorVersion));\n    bytes32 minorNodeId = keccak256(\n      abi.encodePacked(majorNodeId, minorVersion)\n    );\n    bytes32 patchNodeId = keccak256(\n      abi.encodePacked(minorNodeId, patchVersion)\n    );\n\n    ProposedVersion storage proposedVersion = proposedVersions[patchNodeId];\n\n    require(proposedVersion.patchNodeId == 0x0, \"Version is already proposed\");\n\n    proposedVersion.packageId = packageId;\n\n    proposedVersion.majorNodeId = majorNodeId;\n    proposedVersion.minorNodeId = minorNodeId;\n    proposedVersion.patchNodeId = patchNodeId;\n\n    proposedVersion.majorVersion = majorVersion;\n    proposedVersion.minorVersion = minorVersion;\n    proposedVersion.patchVersion = patchVersion;\n\n    proposedVersion.packageLocation = packageLocation;\n    proposedVersion.proposer = proposer;\n\n    MajorVersionQueueContainer\n      storage majorVersionContainer = majorVersionQueueContainers[majorNodeId];\n\n    QueuedVersion storage queuedVersion = majorVersionContainer.queuedVersions[\n      patchNodeId\n    ];\n\n    queuedVersion.patchNodeId = patchNodeId;\n\n    if (majorVersionContainer.tailVersionId != 0x0) {\n      //The queue is not empty\n      QueuedVersion storage tailVersion = majorVersionContainer.queuedVersions[\n        majorVersionContainer.tailVersionId\n      ];\n\n      tailVersion.nextQueuedVersionId = patchNodeId;\n      majorVersionContainer.tailVersionId = patchNodeId;\n    } else {\n      //The queue is empty\n      majorVersionContainer.tailVersionId = patchNodeId;\n      majorVersionContainer.headVersionId = patchNodeId;\n\n      //Since there is only one version in the queue, we can start voting for it\n      startVersionVoting(proposedVersion);\n    }\n\n    emit VersionProposed(\n      packageId,\n      patchNodeId,\n      majorVersion,\n      minorVersion,\n      patchVersion,\n      packageLocation,\n      proposer\n    );\n  }\n\n  function vote(Vote[] memory votes) public {\n    require(\n      authorizedVerifiers[msg.sender],\n      \"You are not an authorized verifier\"\n    );\n\n    for (uint256 i = 0; i < votes.length; i++) {\n      Vote memory vote = votes[i];\n\n      ProposedVersion storage proposedVersion = proposedVersions[\n        vote.patchNodeId\n      ];\n\n      requireCanVoteOnVersion(proposedVersion);\n\n      requireValidMinorVersionPlacement(\n        vote.prevMinorNodeId,\n        vote.nextMinorNodeId,\n        proposedVersion.minorVersion,\n        proposedVersion.majorNodeId,\n        proposedVersion.minorNodeId\n      );\n\n      proposedVersion.votedVerifiers[msg.sender] = true;\n\n      if (vote.approved) {\n        proposedVersion.approvingVerifiers.push(msg.sender);\n      } else {\n        proposedVersion.rejectingVerifiers.push(msg.sender);\n      }\n\n      if (\n        proposedVersion.approvingVerifiers.length > authorizedVerifierCount / 2\n      ) {\n        //The version is verified\n        proposedVersion.decided = true;\n        proposedVersion.verified = true;\n\n        onVersionDecided(\n          vote.prevMinorNodeId,\n          vote.nextMinorNodeId,\n          proposedVersion.minorVersion,\n          proposedVersion.majorNodeId,\n          proposedVersion.minorNodeId,\n          vote.patchNodeId,\n          proposedVersion.verified,\n          proposedVersion.packageLocation\n        );\n      } else {\n        //The version is rejected\n        proposedVersion.decided = true;\n        proposedVersion.verified = false;\n\n        onVersionDecided(\n          vote.prevMinorNodeId,\n          vote.nextMinorNodeId,\n          proposedVersion.minorVersion,\n          proposedVersion.majorNodeId,\n          proposedVersion.minorNodeId,\n          vote.patchNodeId,\n          proposedVersion.verified,\n          proposedVersion.packageLocation\n        );\n      }\n\n      emit VersionVote(\n        msg.sender,\n        proposedVersion.patchNodeId,\n        keccak256(abi.encodePacked(proposedVersion.packageLocation)),\n        vote.approved\n      );\n    }\n  }\n\n  function requireCanVoteOnVersion(ProposedVersion storage proposedVersion)\n    private\n    view\n  {\n    require(proposedVersion.votingStarted, \"Voting has not started\");\n    require(!proposedVersion.decided, \"Voting for this version has ended\");\n    require(!proposedVersion.votedVerifiers[msg.sender], \"You already voted\");\n  }\n\n  function requireValidMinorVersionPlacement(\n    bytes32 prevMinorNodeId,\n    bytes32 nextMinorNodeId,\n    uint256 minorVersionNumber,\n    bytes32 majorNodeId,\n    bytes32 minorNodeId\n  ) private view {\n    VerifiedMinorVersion storage currentVersion = verifiedMinorVersions[\n      minorNodeId\n    ];\n\n    if (currentVersion.patchNodeId != 0x0) {\n      //Minor version has at least one patch version verified and there's no need to keep track of multiple patch versions\n      return;\n    }\n\n    VerifiedMinorVersion storage prevVersion = verifiedMinorVersions[\n      prevMinorNodeId\n    ];\n    VerifiedMinorVersion storage nextVersion = verifiedMinorVersions[\n      nextMinorNodeId\n    ];\n\n    //Verify the current version is between prev and next version\n    if (prevVersion.patchNodeId != 0x0) {\n      require(\n        prevVersion.versionNumber < minorVersionNumber,\n        \"Previous version number is not less than the current one\"\n      );\n      require(\n        prevVersion.nextMinorNodeId == nextMinorNodeId,\n        \"Previous version does not point to the next version\"\n      );\n      require(\n        prevVersion.majorNodeId == majorNodeId,\n        \"Previous version does not belong to the same major version\"\n      );\n    }\n\n    if (nextVersion.patchNodeId != 0x0) {\n      require(\n        minorVersionNumber < nextVersion.versionNumber,\n        \"Next version number is not greater than the current one\"\n      );\n      require(\n        nextVersion.prevMinorNodeId == prevMinorNodeId,\n        \"Next version does not point to the previous version\"\n      );\n      require(\n        nextVersion.majorNodeId == majorNodeId,\n        \"Next version does not belong to the same major version\"\n      );\n    }\n  }\n\n  function startVersionVoting(ProposedVersion storage proposedVersion) private {\n    proposedVersion.votingStarted = true;\n\n    VerifiedMinorVersion memory minorVersion = verifiedMinorVersions[\n      proposedVersion.minorNodeId\n    ];\n\n    emit VersionVotingStarted(\n      proposedVersion.packageId,\n      proposedVersion.patchNodeId,\n      proposedVersion.majorVersion,\n      proposedVersion.minorVersion,\n      proposedVersion.patchVersion,\n      proposedVersion.packageLocation,\n      proposedVersion.proposer,\n      minorVersion.patchNodeId != 0x0\n    );\n  }\n\n  function addToVersionTree(\n    bytes32 prevMinorNodeId,\n    bytes32 nextMinorNodeId,\n    uint256 minorVersionNumber,\n    bytes32 majorNodeId,\n    bytes32 minorNodeId,\n    bytes32 patchNodeId\n  ) private {\n    VerifiedMinorVersion storage currentVersion = verifiedMinorVersions[\n      minorNodeId\n    ];\n\n    currentVersion.patchNodeId = patchNodeId;\n    currentVersion.versionNumber = minorVersionNumber;\n    currentVersion.majorNodeId = majorNodeId;\n\n    VerifiedMinorVersion storage prevVersion = verifiedMinorVersions[\n      prevMinorNodeId\n    ];\n    VerifiedMinorVersion storage nextVersion = verifiedMinorVersions[\n      nextMinorNodeId\n    ];\n\n    //Insert into the linked list between prev and next version\n\n    if (prevVersion.patchNodeId != 0x0) {\n      currentVersion.prevMinorNodeId = prevMinorNodeId;\n      prevVersion.nextMinorNodeId = minorNodeId;\n    }\n\n    if (nextVersion.patchNodeId != 0x0) {\n      currentVersion.nextMinorNodeId = nextMinorNodeId;\n      nextVersion.prevMinorNodeId = minorNodeId;\n    }\n\n    if (prevVersion.patchNodeId == 0x0 && nextVersion.patchNodeId == 0x0) {}\n  }\n\n  function onVersionDecided(\n    bytes32 prevMinorNodeId,\n    bytes32 nextMinorNodeId,\n    uint256 minorVersionNumber,\n    bytes32 majorNodeId,\n    bytes32 minorNodeId,\n    bytes32 patchNodeId,\n    bool verified,\n    string memory packageLocation\n  ) private {\n    bytes32 packageLocationHash = keccak256(abi.encodePacked(packageLocation));\n\n    if (verified) {\n      addToVersionTree(\n        prevMinorNodeId,\n        nextMinorNodeId,\n        minorVersionNumber,\n        majorNodeId,\n        minorNodeId,\n        patchNodeId\n      );\n\n      if (versionVerifiedListener != address(0)) {\n        IVersionVerifiedListener listener = IVersionVerifiedListener(\n          versionVerifiedListener\n        );\n\n        listener.onVersionVerified(patchNodeId, packageLocationHash);\n      }\n    }\n\n    dequeueNextVersion(majorNodeId);\n\n    emit VersionDecided(patchNodeId, verified, packageLocationHash);\n  }\n\n  function dequeueNextVersion(bytes32 majorNodeId) private {\n    MajorVersionQueueContainer\n      storage majorVersionContainer = majorVersionQueueContainers[majorNodeId];\n\n    if (majorVersionContainer.headVersionId == 0x0) {\n      //The queue is empty\n      return;\n    }\n\n    QueuedVersion storage headVersion = majorVersionContainer.queuedVersions[\n      majorVersionContainer.headVersionId\n    ];\n\n    ProposedVersion storage nextVotingVersion = proposedVersions[\n      majorVersionContainer.headVersionId\n    ];\n\n    if (headVersion.nextQueuedVersionId == 0x0) {\n      majorVersionContainer.headVersionId = 0x0;\n      majorVersionContainer.tailVersionId = 0x0;\n    } else {\n      majorVersionContainer.headVersionId = headVersion.nextQueuedVersionId;\n    }\n\n    startVersionVoting(nextVotingVersion);\n  }\n\n  function getPrevPatchPackageLocation(bytes32 patchNodeId)\n    external\n    view\n    returns (string memory prevPackageLocation)\n  {\n    ProposedVersion storage targetVersion = proposedVersions[patchNodeId];\n\n    requireCanVoteOnVersion(targetVersion);\n\n    VerifiedMinorVersion memory minorVersion = verifiedMinorVersions[\n      targetVersion.minorNodeId\n    ];\n\n    assert(minorVersion.patchNodeId != 0x0);\n\n    string memory prevPackageLocation = proposedVersions[\n      minorVersion.patchNodeId\n    ].packageLocation;\n\n    return prevPackageLocation;\n  }\n\n  function getPrevAndNextMinorPackageLocations(bytes32 patchNodeId)\n    external\n    view\n    returns (\n      bytes32 prevMinorNodeId,\n      string memory prevPackageLocation,\n      bytes32 nextMinorNodeId,\n      string memory nextPackageLocation\n    )\n  {\n    ProposedVersion storage targetVersion = proposedVersions[patchNodeId];\n\n    requireCanVoteOnVersion(targetVersion);\n\n    VerifiedMajorVersion memory currentMajorVersion = verifiedMajorVersions[\n      targetVersion.majorNodeId\n    ];\n\n    bytes32 currentMinorNodeId = currentMajorVersion.lowestMinorNodeId;\n    bytes32 nextMinorNodeId = currentMinorNodeId;\n    bytes32 prevMinorNodeId;\n\n    VerifiedMinorVersion memory nextVersion = verifiedMinorVersions[\n      currentMinorNodeId\n    ];\n\n    VerifiedMinorVersion memory prevVersion;\n    while (nextVersion.versionNumber < targetVersion.minorVersion) {\n      prevMinorNodeId = currentMinorNodeId;\n      prevVersion = nextVersion;\n      currentMinorNodeId = nextVersion.nextMinorNodeId;\n      nextVersion = verifiedMinorVersions[currentMinorNodeId];\n    }\n\n    string memory prevPackageLocation;\n    if (prevVersion.patchNodeId != 0x0) {\n      prevPackageLocation = proposedVersions[prevVersion.patchNodeId]\n        .packageLocation;\n    }\n\n    string memory nextPackageLocation;\n    if (nextVersion.patchNodeId != 0x0) {\n      nextPackageLocation = proposedVersions[nextVersion.patchNodeId]\n        .packageLocation;\n    }\n\n    return (\n      prevMinorNodeId,\n      prevPackageLocation,\n      nextMinorNodeId,\n      nextPackageLocation\n    );\n  }\n\n  function getProposedVersionVotingInfo(bytes32 patchNodeId) public view returns(uint256 verifierCount, uint256 approvingVerifiers, uint256 rejectingVerifiers) {\n    ProposedVersion storage proposedVersion = proposedVersions[patchNodeId];\n\n    return (authorizedVerifierCount, proposedVersion.approvingVerifiers.length, proposedVersion.rejectingVerifiers.length);\n  }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal initializer {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal initializer {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n}\n"
    },
    "contracts/versioning/version-events-listeners/IVersionVerifiedListener.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface IVersionVerifiedListener {\n  function onVersionVerified(bytes32 patchNodeId, bytes32 packageLocationHash)\n    external;\n}\n"
    },
    "contracts/versioning/registrar/PolywrapRegistrar.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./Registrar.sol\";\n\ncontract PolywrapRegistrar is Registrar {\n  constructor(address _registry) Registrar(_registry) {}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}