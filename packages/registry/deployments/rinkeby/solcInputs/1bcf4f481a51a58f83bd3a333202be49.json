{
  "language": "Solidity",
  "sources": {
    "contracts/versioning/PackageOwnershipManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"./registry/Registry.sol\";\nimport \"./bridges/interfaces/IOwnershipBridgeLink.sol\";\nimport \"./domain-registries/interfaces/IDomainRegistryLink.sol\";\n\ncontract PackageOwnershipManager is OwnableUpgradeable {\n  address public registry;\n\n  mapping(bytes32 => address) public domainRegistryLinks;\n\n  mapping(bytes32 => bool) public allowedLocalDomainRegistries;\n  mapping(bytes32 => address) public incomingBridgeLinks;\n  mapping(bytes32 => address) public outgoingBridgeLinks;\n\n  constructor(\n    address owner,\n    address _registry,\n    bytes32[] memory _domainRegistries,\n    address[] memory _domainRegistryLinks\n  ) {\n    initialize(_registry, _domainRegistries, _domainRegistryLinks);\n    transferOwnership(owner);\n  }\n\n  function initialize(\n    address _registry,\n    bytes32[] memory _domainRegistries,\n    address[] memory _domainRegistryLinks\n  ) public initializer {\n    __Ownable_init();\n\n    registry = _registry;\n\n    require(\n      _domainRegistries.length == _domainRegistryLinks.length,\n      \"Registry arrays must have the same length\"\n    );\n\n    for (uint256 i = 0; i < _domainRegistries.length; i++) {\n      domainRegistryLinks[_domainRegistries[i]] = _domainRegistryLinks[i];\n    }\n  }\n\n  function updateRegistry(address _registry) public {\n    registry = _registry;\n  }\n\n  function updateLocalDomainRegistryPermission(\n    bytes32 domainRegistry,\n    bool allowed\n  ) public onlyOwner {\n    allowedLocalDomainRegistries[domainRegistry] = allowed;\n  }\n\n  function updateIncomingBridgeLink(\n    bytes32 domainRegistry,\n    bytes32 blockchainName,\n    address bridgeLink\n  ) public onlyOwner {\n    bytes32 key = keccak256(abi.encodePacked(domainRegistry, blockchainName));\n\n    incomingBridgeLinks[key] = bridgeLink;\n  }\n\n  function updateOutgoingBridgeLink(\n    bytes32 domainRegistry,\n    bytes32 blockchainName,\n    address bridgeLink\n  ) public onlyOwner {\n    bytes32 key = keccak256(abi.encodePacked(domainRegistry, blockchainName));\n\n    outgoingBridgeLinks[key] = bridgeLink;\n  }\n\n  function connectDomainRegistryLink(\n    bytes32 domainRegistry,\n    address _domainRegistryLink\n  ) public onlyOwner {\n    domainRegistryLinks[domainRegistry] = _domainRegistryLink;\n  }\n\n  function updateOwnership(bytes32 domainRegistry, bytes32 domainRegistryNode)\n    public\n  {\n    require(\n      allowedLocalDomainRegistries[domainRegistry],\n      \"Domain registry is not allowed for local updates\"\n    );\n\n    address owner = getPolywrapOwner(domainRegistry, domainRegistryNode);\n\n    Registry(registry).updateOwnership(\n      domainRegistry,\n      domainRegistryNode,\n      owner\n    );\n  }\n\n  function relayOwnership(\n    bytes32 blockchainName,\n    bytes32 domainRegistry,\n    bytes32 domainRegistryNode\n  ) public {\n    address bridgeLink = outgoingBridgeLinks[\n      keccak256(abi.encodePacked(domainRegistry, blockchainName))\n    ];\n\n    require(\n      bridgeLink != address(0),\n      \"Outgoing relay not supported for domain registry and blockchain\"\n    );\n\n    address owner = getPolywrapOwner(domainRegistry, domainRegistryNode);\n\n    IOwnershipBridgeLink(bridgeLink).relayOwnership(\n      domainRegistry,\n      domainRegistryNode,\n      owner\n    );\n  }\n\n  function receiveOwnership(\n    bytes32 blockchainName,\n    bytes32 domainRegistry,\n    bytes32 domainRegistryNode,\n    address owner\n  ) public {\n    address bridgeLink = incomingBridgeLinks[\n      keccak256(abi.encodePacked(domainRegistry, blockchainName))\n    ];\n\n    require(\n      bridgeLink != address(0),\n      \"Incoming relay not supported for domain registry and blockchain\"\n    );\n\n    assert(msg.sender == bridgeLink);\n\n    Registry(registry).updateOwnership(\n      domainRegistry,\n      domainRegistryNode,\n      owner\n    );\n  }\n\n  function getPolywrapOwner(bytes32 domainRegistry, bytes32 domainRegistryNode)\n    public\n    view\n    returns (address)\n  {\n    address domainRegistryLinkAddress = domainRegistryLinks[domainRegistry];\n\n    require(\n      domainRegistryLinkAddress != address(0),\n      \"Domain registry is not supported\"\n    );\n\n    return\n      IDomainRegistryLink(domainRegistryLinkAddress).getPolywrapOwner(\n        domainRegistryNode\n      );\n  }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal initializer {\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal initializer {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/versioning/registry/Registry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nabstract contract Registry is OwnableUpgradeable {\n  event OwnershipUpdated(\n    bytes32 indexed domainRegistryNode,\n    bytes32 packageId,\n    bytes32 domainRegistry,\n    address indexed owner\n  );\n\n  event VersionPublished(\n    bytes32 indexed packageId,\n    uint256 major,\n    uint256 minor,\n    uint256 patch,\n    string location\n  );\n\n  struct PackageVersion {\n    bool leaf;\n    uint256 latestSubVersion;\n    bool created;\n    string location; // empty on non-leaf nodes\n  }\n\n  struct PackageInfo {\n    address owner;\n    bytes32 domainRegistryNode;\n    bytes32 domainRegistry;\n  }\n\n  mapping(bytes32 => PackageVersion) public versionNodes;\n  mapping(bytes32 => PackageInfo) public packages;\n  address public ownershipUpdater;\n  address public versionPublisher;\n\n  constructor(\n    address owner\n  ) {\n    initialize();\n    transferOwnership(owner);\n  }\n\n  function initialize() public initializer {\n    __Ownable_init();\n  }\n\n  function updateOwnershipUpdater(address _ownershipUpdater) public onlyOwner {\n    ownershipUpdater = _ownershipUpdater;\n  }\n\n  function updateVersionPublisher(address _versionPublisher) public onlyOwner {\n    versionPublisher = _versionPublisher;\n  }\n\n  function updateOwnership(\n    bytes32 domainRegistry,\n    bytes32 domainRegistryNode,\n    address domainOwner\n  ) public {\n    assert(msg.sender == ownershipUpdater);\n\n    bytes32 packageId = keccak256(\n      abi.encodePacked(\n        keccak256(abi.encodePacked(domainRegistryNode)),\n        domainRegistry\n      )\n    );\n\n    packages[packageId] = PackageInfo(\n      domainOwner,\n      domainRegistryNode,\n      domainRegistry\n    );\n\n    emit OwnershipUpdated(\n      domainRegistryNode,\n      packageId,\n      domainRegistry,\n      domainOwner\n    );\n  }\n\n  function publishVersion(\n    bytes32 packageId,\n    uint256 majorVersion,\n    uint256 minorVersion,\n    uint256 patchVersion,\n    string memory location\n  ) public returns (bytes32) {\n    assert(msg.sender == versionPublisher);\n\n    bytes32 majorNodeId = keccak256(abi.encodePacked(packageId, majorVersion));\n    bytes32 minorNodeId = keccak256(\n      abi.encodePacked(majorNodeId, minorVersion)\n    );\n    bytes32 patchNodeId = keccak256(\n      abi.encodePacked(minorNodeId, patchVersion)\n    );\n\n    PackageVersion storage packageNode = versionNodes[packageId];\n    PackageVersion storage majorNode = versionNodes[majorNodeId];\n    PackageVersion storage minorNode = versionNodes[minorNodeId];\n\n    if (packageNode.latestSubVersion < majorVersion) {\n      packageNode.latestSubVersion = majorVersion;\n    }\n    packageNode.created = true;\n\n    if (majorNode.latestSubVersion < minorVersion) {\n      majorNode.latestSubVersion = minorVersion;\n    }\n    majorNode.created = true;\n\n    if (minorNode.latestSubVersion < patchVersion) {\n      minorNode.latestSubVersion = patchVersion;\n    }\n    minorNode.created = true;\n\n    require(!versionNodes[patchNodeId].created, \"Version is already published\");\n\n    versionNodes[patchNodeId] = PackageVersion(true, 0, true, location);\n\n    emit VersionPublished(\n      packageId,\n      majorVersion,\n      minorVersion,\n      patchVersion,\n      location\n    );\n\n    return patchNodeId;\n  }\n\n  function getPackageOwner(bytes32 packageId) public view returns (address) {\n    return packages[packageId].owner;\n  }\n}\n"
    },
    "contracts/versioning/bridges/interfaces/IOwnershipBridgeLink.sol": {
      "content": "pragma solidity ^0.8.4;\n\ninterface IOwnershipBridgeLink {\n  function relayOwnership(\n    bytes32 domainRegistrar,\n    bytes32 domainRegistrarNode,\n    address owner\n  ) external;\n\n  function receiveOwnership(\n    bytes32 domainRegistrar,\n    bytes32 domainRegistrarNode,\n    address owner\n  ) external;\n}\n"
    },
    "contracts/versioning/domain-registries/interfaces/IDomainRegistryLink.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface IDomainRegistryLink {\n  function getPolywrapOwner(bytes32 domainRegistryNode)\n    external\n    view\n    returns (address);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal initializer {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal initializer {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n}\n"
    },
    "contracts/versioning/bridges/token-bridge/VerificationRootBridgeLink.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"../../VersionVerificationManager.sol\";\nimport \"../../PackageOwnershipManager.sol\";\nimport \"./ITokenBridge.sol\";\nimport \"../interfaces/IVerificationRootBridgeLink.sol\";\n\ncontract VerificationRootBridgeLink is\n  IVerificationRootBridgeLink,\n  OwnableUpgradeable\n{\n  address public bridge;\n  address public bridgeLink;\n  address public verificationRootRelayer;\n  address public versionVerificationManager;\n  bytes32 public bridgeChainId;\n  uint256 public relayVerificationRootGasLimit;\n\n  constructor(\n    address owner,\n    address _bridge,\n    bytes32 _bridgeChainId,\n    uint256 _relayVerificationRootGasLimit\n  ) {\n    initialize(_bridge, _bridgeChainId, _relayVerificationRootGasLimit);\n    transferOwnership(owner);\n  }\n\n  function initialize(\n    address _bridge,\n    bytes32 _bridgeChainId,\n    uint256 _relayVerificationRootGasLimit\n  ) public initializer {\n    __Ownable_init();\n\n    bridge = _bridge;\n    bridgeChainId = _bridgeChainId;\n    relayVerificationRootGasLimit = _relayVerificationRootGasLimit;\n  }\n\n  function updateBridge(address _bridge) public onlyOwner {\n    bridge = _bridge;\n  }\n\n  function updateBridgeLink(address _bridgeLink) public onlyOwner {\n    bridgeLink = _bridgeLink;\n  }\n\n  function updateVerificationRootRelayer(address _verificationRootRelayer)\n    public\n    onlyOwner\n  {\n    verificationRootRelayer = _verificationRootRelayer;\n  }\n\n  function updateVersionVerificationManager(address _versionVerificationManager)\n    public\n    onlyOwner\n  {\n    versionVerificationManager = _versionVerificationManager;\n  }\n\n  function updateBridgeChainId(bytes32 _bridgeChainId) public onlyOwner {\n    bridgeChainId = _bridgeChainId;\n  }\n\n  function updateRelayVerificationRootGasLimit(\n    uint256 _relayVerificationRootGasLimit\n  ) public onlyOwner {\n    relayVerificationRootGasLimit = _relayVerificationRootGasLimit;\n  }\n\n  function relayVerificationRoot(bytes32 verificationRoot)\n    public\n    virtual\n    override\n  {\n    assert(msg.sender == verificationRootRelayer);\n\n    bytes4 methodSelector = IVerificationRootBridgeLink(address(0))\n      .receiveVerificationRoot\n      .selector;\n    bytes memory data = abi.encodeWithSelector(\n      methodSelector,\n      verificationRoot\n    );\n    ITokenBridge(bridge).requireToPassMessage(\n      bridgeLink,\n      data,\n      relayVerificationRootGasLimit\n    );\n  }\n\n  function receiveVerificationRoot(bytes32 verificationRoot)\n    public\n    virtual\n    override\n  {\n    assert(msg.sender == bridge);\n\n    ITokenBridge bridgeContract = ITokenBridge(bridge);\n    require(bridgeContract.messageSender() == bridgeLink);\n    require(bridgeContract.messageSourceChainId() == bridgeChainId);\n\n    VersionVerificationManager(versionVerificationManager)\n      .updateVerificationRoot(verificationRoot);\n  }\n}\n"
    },
    "contracts/versioning/VersionVerificationManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"./registry/Registry.sol\";\n\ncontract VersionVerificationManager is OwnableUpgradeable {\n  event VersionPublished(\n    bytes32 indexed packageId,\n    bytes32 indexed verifiedVersionId,\n    bytes32 indexed patchNodeId,\n    uint256 major,\n    uint256 minor,\n    uint256 patch,\n    string location\n  );\n\n  address public registry;\n  address public verificationRootUpdater;\n\n  bytes32 public verificationRoot;\n\n  constructor(\n    address owner,\n    address _registry\n  ) {\n    initialize(_registry);\n    transferOwnership(owner);\n  }\n\n  function initialize(address _registry) public initializer {\n    __Ownable_init();\n\n    registry = _registry;\n  }\n\n  function updateRegistry(address _registry) public onlyOwner {\n    registry = _registry;\n  }\n\n  function updateVerificationRootUpdater(address _verificationRootUpdater)\n    public\n    onlyOwner\n  {\n    verificationRootUpdater = _verificationRootUpdater;\n  }\n\n  function updateVerificationRoot(bytes32 root) public {\n    assert(msg.sender == verificationRootUpdater);\n\n    verificationRoot = root;\n  }\n\n  function publishVersion(\n    bytes32 packageId,\n    bytes32 patchNodeId,\n    uint256 majorVersion,\n    uint256 minorVersion,\n    uint256 patchVersion,\n    string memory location,\n    bytes32[] memory proof,\n    bool[] memory sides\n  ) public packageOwner(packageId) {\n    bytes32 verifiedVersionId = keccak256(\n      abi.encodePacked(patchNodeId, keccak256(abi.encodePacked(location)))\n    );\n\n    require(\n      proveVerifiedVersion(proof, sides, verifiedVersionId, verificationRoot),\n      \"Invalid proof\"\n    );\n\n    bytes32 actualPatchNodeId = Registry(registry).publishVersion(\n      packageId,\n      majorVersion,\n      minorVersion,\n      patchVersion,\n      location\n    );\n\n    require(\n      patchNodeId == actualPatchNodeId,\n      \"Supplied patchNodeId does not match the calculated patchNodeId\"\n    );\n\n    emit VersionPublished(\n      packageId,\n      verifiedVersionId,\n      patchNodeId,\n      majorVersion,\n      minorVersion,\n      patchVersion,\n      location\n    );\n  }\n\n  function proveVerifiedVersion(\n    bytes32[] memory proof,\n    bool[] memory sides,\n    bytes32 verifiedVersionId,\n    bytes32 root\n  ) private pure returns (bool) {\n    bytes32 hash = verifiedVersionId;\n\n    for (uint256 i = 0; i < proof.length; i++) {\n      bytes32 proofElement = proof[i];\n\n      if (sides[i]) {\n        hash = keccak256(abi.encodePacked(proofElement, hash));\n      } else {\n        hash = keccak256(abi.encodePacked(hash, proofElement));\n      }\n    }\n\n    return hash == root;\n  }\n\n  modifier packageOwner(bytes32 packageId) {\n    require(\n      getPackageOwner(packageId) == msg.sender,\n      \"You do not have access to the domain of this package\"\n    );\n    _;\n  }\n\n  function getPackageOwner(bytes32 packageId) private view returns (address) {\n    return Registry(registry).getPackageOwner(packageId);\n  }\n}\n"
    },
    "contracts/versioning/bridges/token-bridge/ITokenBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface ITokenBridge {\n  function requireToPassMessage(\n    address _contract,\n    bytes calldata _data,\n    uint256 _gas\n  ) external returns (bytes32);\n\n  function messageSender() external view returns (address);\n\n  function messageSourceChainId() external view returns (bytes32);\n}\n"
    },
    "contracts/versioning/bridges/interfaces/IVerificationRootBridgeLink.sol": {
      "content": "pragma solidity ^0.8.4;\n\ninterface IVerificationRootBridgeLink {\n  function relayVerificationRoot(bytes32 verificationRoot) external;\n\n  function receiveVerificationRoot(bytes32 verificationRoot) external;\n}\n"
    },
    "contracts/versioning/VerificationRootRelayer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"./bridges/interfaces/IVerificationRootBridgeLink.sol\";\nimport \"./VerificationTreeManager.sol\";\nimport \"./VersionVerificationManager.sol\";\n\ncontract VerificationRootRelayer is OwnableUpgradeable {\n  address public versionVerificationManager;\n  address public bridgeLink;\n  address public verificationTreeManager;\n  uint256 public blocksPerRootRelay;\n\n  uint256 public lastRootRelayBlock;\n\n  constructor(\n    address owner,\n    address _versionVerificationManager, \n    uint256 _blocksPerRootRelay\n  ) {\n    initialize(_versionVerificationManager, _blocksPerRootRelay);\n    transferOwnership(owner);\n  }\n\n  function initialize(\n    address _versionVerificationManager,\n    uint256 _blocksPerRootRelay\n  ) public initializer {\n    __Ownable_init();\n\n    versionVerificationManager = _versionVerificationManager;\n    blocksPerRootRelay = _blocksPerRootRelay;\n  }\n\n  function updateBridgeLink(address _bridgeLink) public onlyOwner {\n    bridgeLink = _bridgeLink;\n  }\n\n  function updateVersionVerificationManager(address _versionVerificationManager)\n    public\n    onlyOwner\n  {\n    versionVerificationManager = _versionVerificationManager;\n  }\n\n  function updateVerificationTreeManager(address _verificationTreeManager)\n    public\n    onlyOwner\n  {\n    verificationTreeManager = _verificationTreeManager;\n  }\n\n  function updateBlocksPerRootRelay(uint256 _blocksPerRootRelay)\n    public\n    onlyOwner\n  {\n    blocksPerRootRelay = _blocksPerRootRelay;\n  }\n\n  function onVersionVerified() public {\n    assert(msg.sender == verificationTreeManager);\n\n    bytes32 verificationRoot = VerificationTreeManager(verificationTreeManager)\n      .calculateVerificationRoot();\n\n    updateVerificationRoot(verificationRoot);\n\n    if (block.number < lastRootRelayBlock + blocksPerRootRelay) {\n      return;\n    }\n\n    relayVerificationRoot();\n  }\n\n  function relayVerificationRoot() public {\n    assert(versionVerificationManager != address(0));\n\n    if (bridgeLink == address(0)) {\n      return;\n    }\n\n    bytes32 verificationRoot = VersionVerificationManager(\n      versionVerificationManager\n    ).verificationRoot();\n\n    IVerificationRootBridgeLink(bridgeLink).relayVerificationRoot(\n      verificationRoot\n    );\n  }\n\n  function updateVerificationRoot(bytes32 verificationRoot) private {\n    if (versionVerificationManager != address(0)) {\n      VersionVerificationManager(versionVerificationManager)\n        .updateVerificationRoot(verificationRoot);\n    }\n  }\n}\n"
    },
    "contracts/versioning/VerificationTreeManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"./version-events-listeners/IVersionVerifiedListener.sol\";\nimport \"./VerificationRootRelayer.sol\";\n\ncontract VerificationTreeManager is\n  IVersionVerifiedListener,\n  OwnableUpgradeable\n{\n  event VerificationRootCalculated(\n    bytes32 indexed verificationRoot,\n    uint256 verifiedVersionCount\n  );\n\n  event VersionVerified(\n    bytes32 indexed patchNodeId,\n    bytes32 packageLocationHash,\n    uint256 verifiedVersionIndex\n  );\n\n  struct DynamicMerkleTree {\n    //Track unpaired leaves and the highest level(root is at the top) to calculate the merkle root on the fly\n    uint256 highestTreeLevel;\n    mapping(uint256 => bytes32) unpairedTreeLeaves;\n  }\n\n  DynamicMerkleTree private verificationTree;\n\n  address public registry;\n  address public votingMachine;\n  address public verificationRootRelayer;\n\n  uint256 public verifiedVersionCount;\n\n  constructor(\n    address owner,\n    address _registry, \n    address _votingMachine\n  ) {\n    initialize(_registry, _votingMachine);\n    transferOwnership(owner);\n  }\n\n  function initialize(address _registry, address _votingMachine)\n    public\n    initializer\n  {\n    __Ownable_init();\n\n    registry = _registry;\n    votingMachine = _votingMachine;\n  }\n\n  function updateRegistry(address _registry) public onlyOwner {\n    registry = _registry;\n  }\n\n  function updateVotingMachine(address _votingMachine) public onlyOwner {\n    votingMachine = _votingMachine;\n  }\n\n  function updateVerificationRootRelayer(address _verificationRootRelayer)\n    public\n    onlyOwner\n  {\n    verificationRootRelayer = _verificationRootRelayer;\n  }\n\n  function onVersionVerified(bytes32 patchNodeId, bytes32 packageLocationHash)\n    public\n    override\n  {\n    assert(msg.sender == votingMachine);\n\n    addVersionToTree(patchNodeId, packageLocationHash);\n\n    emit VersionVerified(\n      patchNodeId,\n      packageLocationHash,\n      verifiedVersionCount\n    );\n\n    verifiedVersionCount++;\n\n    VerificationRootRelayer(verificationRootRelayer).onVersionVerified();\n  }\n\n  function addVersionToTree(bytes32 patchNodeId, bytes32 packageLocationHash)\n    private\n  {\n    bytes32 leaf = keccak256(\n      abi.encodePacked(patchNodeId, packageLocationHash)\n    );\n\n    //Go through the unpaired tree leaves and pair them with the new leaf\n    uint256 currentTreeLevel = 0;\n    while (verificationTree.unpairedTreeLeaves[currentTreeLevel] != 0x0) {\n      leaf = keccak256(\n        abi.encodePacked(\n          verificationTree.unpairedTreeLeaves[currentTreeLevel],\n          leaf\n        )\n      );\n\n      verificationTree.unpairedTreeLeaves[currentTreeLevel] = 0x0;\n      currentTreeLevel++;\n    }\n\n    //Store the unpaired leaf to be paired later\n    verificationTree.unpairedTreeLeaves[currentTreeLevel] = leaf;\n\n    //Track the highest level\n    if (currentTreeLevel > verificationTree.highestTreeLevel) {\n      verificationTree.highestTreeLevel = currentTreeLevel;\n    }\n  }\n\n  function calculateVerificationRoot() public returns (bytes32) {\n    assert(msg.sender == verificationRootRelayer);\n\n    bytes32 leaf = 0x0;\n\n    //Go through the unpaired tree leaves and pair them with the \"0x0\" leaf\n    //If there is no unpaired leaf, just propagate the current one upwards\n    uint256 currentTreeLevel = 0;\n    while (currentTreeLevel <= verificationTree.highestTreeLevel) {\n      if (verificationTree.unpairedTreeLeaves[currentTreeLevel] != 0x0) {\n        if (leaf == 0x0) {\n          leaf = verificationTree.unpairedTreeLeaves[currentTreeLevel];\n        } else {\n          leaf = keccak256(\n            abi.encodePacked(\n              verificationTree.unpairedTreeLeaves[currentTreeLevel],\n              leaf\n            )\n          );\n        }\n      }\n\n      currentTreeLevel++;\n    }\n\n    emit VerificationRootCalculated(leaf, verifiedVersionCount);\n\n    return leaf;\n  }\n}\n"
    },
    "contracts/versioning/version-events-listeners/IVersionVerifiedListener.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface IVersionVerifiedListener {\n  function onVersionVerified(bytes32 patchNodeId, bytes32 packageLocationHash)\n    external;\n}\n"
    },
    "contracts/versioning/registry/VersionResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./Registry.sol\";\n\nabstract contract VersionResolver is Registry {\n  function resolveToLeaf(bytes32 versionNodeId) public view returns (bytes32) {\n    PackageVersion storage versionNode = versionNodes[versionNodeId];\n    require(versionNode.created, \"Invalid Node\");\n\n    if (versionNode.leaf) {\n      return versionNodeId;\n    }\n\n    bytes32 latestNodeId = keccak256(\n      abi.encodePacked(versionNodeId, versionNode.latestSubVersion)\n    );\n\n    return resolveToLeaf(latestNodeId);\n  }\n\n  function getPackageLocation(bytes32 versionNodeId)\n    public\n    view\n    returns (string memory)\n  {\n    bytes32 concreteVersionId = resolveToLeaf(versionNodeId);\n    return versionNodes[concreteVersionId].location;\n  }\n}\n"
    },
    "contracts/versioning/registry/PolywrapRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./VersionResolver.sol\";\n\ncontract PolywrapRegistry is VersionResolver {\n  constructor(address owner) Registry(owner) {}\n}\n"
    },
    "contracts/versioning/registrar/Registrar.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"../registry/VersionResolver.sol\";\nimport \"../registry/Registry.sol\";\nimport \"../VotingMachine.sol\";\n\nabstract contract Registrar is OwnableUpgradeable {\n  event ManagerAdded(bytes32 indexed packageId, address indexed manager);\n  event ManagerRemoved(bytes32 indexed packageId, address indexed manager);\n\n  address public registry;\n  address public votingMachine;\n\n  mapping(bytes32 => bool) public managers;\n\n  constructor(\n    address owner,\n    address _registry\n  ) {\n    initialize(_registry);\n    transferOwnership(owner);\n  }\n\n  function initialize(address _registry) public initializer {\n    __Ownable_init();\n\n    registry = _registry;\n  }\n\n  function updateRegistry(address _registry) public onlyOwner {\n    registry = _registry;\n  }\n\n  function updateVotingMachine(address _votingMachine) public onlyOwner {\n    votingMachine = _votingMachine;\n  }\n\n  function addManager(bytes32 packageId, address manager)\n    public\n    packageOwner(packageId)\n  {\n    bytes32 key = keccak256(abi.encodePacked(packageId, manager));\n\n    managers[key] = true;\n\n    emit ManagerAdded(packageId, manager);\n  }\n\n  function removeManager(bytes32 packageId, address manager)\n    public\n    packageOwner(packageId)\n  {\n    bytes32 key = keccak256(abi.encodePacked(packageId, manager));\n\n    managers[key] = false;\n\n    emit ManagerRemoved(packageId, manager);\n  }\n\n  function proposeVersion(\n    bytes32 packageId,\n    uint256 majorVersion,\n    uint256 minorVersion,\n    uint256 patchVersion,\n    string calldata packageLocation\n  ) public {\n    VotingMachine votingMachineContract = VotingMachine(votingMachine);\n\n    votingMachineContract.proposeVersion(\n      packageId,\n      majorVersion,\n      minorVersion,\n      patchVersion,\n      packageLocation,\n      msg.sender\n    );\n  }\n\n  function isAuthorized(bytes32 packageId, address ownerOrManager)\n    public\n    view\n    returns (bool)\n  {\n    bytes32 key = keccak256(abi.encodePacked(packageId, ownerOrManager));\n\n    if (managers[key]) {\n      return true;\n    }\n\n    return getPackageOwner(packageId) == ownerOrManager;\n  }\n\n  modifier authorized(bytes32 packageId) {\n    require(\n      isAuthorized(packageId, msg.sender),\n      \"You do not have access to this package\"\n    );\n    _;\n  }\n\n  modifier packageOwner(bytes32 packageId) {\n    require(\n      getPackageOwner(packageId) == msg.sender,\n      \"You do not have access to the domain of this package\"\n    );\n    _;\n  }\n\n  function getPackageOwner(bytes32 packageId) private view returns (address) {\n    return Registry(registry).getPackageOwner(packageId);\n  }\n}\n"
    },
    "contracts/versioning/VotingMachine.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"./version-events-listeners/IVersionVerifiedListener.sol\";\n\ncontract VotingMachine is OwnableUpgradeable {\n  event VersionProposed(\n    bytes32 indexed packageId,\n    bytes32 patchNodeId,\n    uint256 majorVersion,\n    uint256 minorVersion,\n    uint256 patchVersion,\n    string packageLocation,\n    address proposer\n  );\n\n  event VersionVotingStarted(\n    bytes32 indexed packageId,\n    bytes32 indexed patchNodeId,\n    uint256 majorVersion,\n    uint256 minorVersion,\n    uint256 patchVersion,\n    string packageLocation,\n    address proposer,\n    bool isPatch\n  );\n\n  event VersionVote(\n    address indexed verifier,\n    bytes32 indexed patchNodeId,\n    bytes32 packageLocationHash,\n    bool approved\n  );\n\n  event VersionDecided(\n    bytes32 indexed patchNodeId,\n    bool indexed verified,\n    bytes32 packageLocationHash\n  );\n\n  struct ProposedVersion {\n    address[] approvingVerifiers;\n    address[] rejectingVerifiers;\n    mapping(address => bool) votedVerifiers;\n    bool decided;\n    bool verified;\n    bool votingStarted;\n    bytes32 packageId;\n    bytes32 majorNodeId;\n    bytes32 minorNodeId;\n    bytes32 patchNodeId;\n    string packageLocation;\n    uint256 majorVersion;\n    uint256 minorVersion;\n    uint256 patchVersion;\n    address proposer;\n  }\n\n  struct QueuedVersion {\n    bytes32 nextQueuedVersionId;\n    bytes32 patchNodeId;\n  }\n\n  struct MajorVersionQueueContainer {\n    bytes32 headVersionId;\n    bytes32 tailVersionId;\n    mapping(bytes32 => QueuedVersion) queuedVersions;\n  }\n\n  struct VerifiedMajorVersion {\n    bytes32 lowestMinorNodeId;\n  }\n\n  struct VerifiedMinorVersion {\n    uint256 versionNumber;\n    bytes32 nextMinorNodeId;\n    bytes32 prevMinorNodeId;\n    bytes32 majorNodeId;\n    bytes32 patchNodeId;\n  }\n\n  struct Vote {\n    bytes32 patchNodeId;\n    bytes32 prevMinorNodeId;\n    bytes32 nextMinorNodeId;\n    bool approved;\n  }\n\n  address public registrar;\n  address public versionVerifiedListener;\n\n  mapping(bytes32 => MajorVersionQueueContainer)\n    public majorVersionQueueContainers;\n  mapping(bytes32 => ProposedVersion) public proposedVersions;\n  mapping(bytes32 => VerifiedMinorVersion) public verifiedMinorVersions;\n  mapping(bytes32 => VerifiedMajorVersion) public verifiedMajorVersions;\n\n  mapping(address => bool) public authorizedVerifiers;\n  uint256 public authorizedVerifierCount;\n\n  constructor(\n    address owner,\n    address _registrar\n  ) {\n    initialize(_registrar);\n    transferOwnership(owner);\n  }\n\n  function initialize(address _registrar) public initializer {\n    __Ownable_init();\n\n    registrar = _registrar;\n  }\n\n  function updateRegistrar(address _registrar) public onlyOwner {\n    registrar = _registrar;\n  }\n\n  function updateVersionVerifiedListener(address _versionVerifiedListener)\n    public\n    onlyOwner\n  {\n    versionVerifiedListener = _versionVerifiedListener;\n  }\n\n  function authorizeVerifiers(address[] memory addresses) public onlyOwner {\n    for (uint256 i = 0; i < addresses.length; i++) {\n      if (!authorizedVerifiers[addresses[i]]) {\n        authorizedVerifiers[addresses[i]] = true;\n        authorizedVerifierCount++;\n      }\n    }\n  }\n\n  function unauthorizeVerifiers(address[] memory addresses) public onlyOwner {\n    for (uint256 i = 0; i < addresses.length; i++) {\n      if (authorizedVerifiers[addresses[i]]) {\n        authorizedVerifiers[addresses[i]] = false;\n        authorizedVerifierCount--;\n      }\n    }\n  }\n\n  function proposeVersion(\n    bytes32 packageId,\n    uint256 majorVersion,\n    uint256 minorVersion,\n    uint256 patchVersion,\n    string calldata packageLocation,\n    address proposer\n  ) public {\n    assert(msg.sender == registrar);\n\n    bytes32 majorNodeId = keccak256(abi.encodePacked(packageId, majorVersion));\n    bytes32 minorNodeId = keccak256(\n      abi.encodePacked(majorNodeId, minorVersion)\n    );\n    bytes32 patchNodeId = keccak256(\n      abi.encodePacked(minorNodeId, patchVersion)\n    );\n\n    ProposedVersion storage proposedVersion = proposedVersions[patchNodeId];\n\n    require(proposedVersion.patchNodeId == 0x0, \"Version is already proposed\");\n\n    proposedVersion.packageId = packageId;\n\n    proposedVersion.majorNodeId = majorNodeId;\n    proposedVersion.minorNodeId = minorNodeId;\n    proposedVersion.patchNodeId = patchNodeId;\n\n    proposedVersion.majorVersion = majorVersion;\n    proposedVersion.minorVersion = minorVersion;\n    proposedVersion.patchVersion = patchVersion;\n\n    proposedVersion.packageLocation = packageLocation;\n    proposedVersion.proposer = proposer;\n\n    MajorVersionQueueContainer\n      storage majorVersionContainer = majorVersionQueueContainers[majorNodeId];\n\n    QueuedVersion storage queuedVersion = majorVersionContainer.queuedVersions[\n      patchNodeId\n    ];\n\n    queuedVersion.patchNodeId = patchNodeId;\n\n    if (majorVersionContainer.tailVersionId != 0x0) {\n      //The queue is not empty\n      QueuedVersion storage tailVersion = majorVersionContainer.queuedVersions[\n        majorVersionContainer.tailVersionId\n      ];\n\n      tailVersion.nextQueuedVersionId = patchNodeId;\n      majorVersionContainer.tailVersionId = patchNodeId;\n    } else {\n      //The queue is empty\n      majorVersionContainer.tailVersionId = patchNodeId;\n      majorVersionContainer.headVersionId = patchNodeId;\n\n      //Since there is only one version in the queue, we can start voting for it\n      startVersionVoting(proposedVersion);\n    }\n\n    emit VersionProposed(\n      packageId,\n      patchNodeId,\n      majorVersion,\n      minorVersion,\n      patchVersion,\n      packageLocation,\n      proposer\n    );\n  }\n\n  function vote(Vote[] memory votes) public {\n    require(\n      authorizedVerifiers[msg.sender],\n      \"You are not an authorized verifier\"\n    );\n\n    for (uint256 i = 0; i < votes.length; i++) {\n      Vote memory vote = votes[i];\n\n      ProposedVersion storage proposedVersion = proposedVersions[\n        vote.patchNodeId\n      ];\n\n      requireCanVoteOnVersion(proposedVersion);\n\n      requireValidMinorVersionPlacement(\n        vote.prevMinorNodeId,\n        vote.nextMinorNodeId,\n        proposedVersion.minorVersion,\n        proposedVersion.majorNodeId,\n        proposedVersion.minorNodeId\n      );\n\n      proposedVersion.votedVerifiers[msg.sender] = true;\n\n      if (vote.approved) {\n        proposedVersion.approvingVerifiers.push(msg.sender);\n      } else {\n        proposedVersion.rejectingVerifiers.push(msg.sender);\n      }\n\n      if (\n        proposedVersion.approvingVerifiers.length > authorizedVerifierCount / 2\n      ) {\n        //The version is verified\n        proposedVersion.decided = true;\n        proposedVersion.verified = true;\n\n        onVersionDecided(\n          vote.prevMinorNodeId,\n          vote.nextMinorNodeId,\n          proposedVersion.minorVersion,\n          proposedVersion.majorNodeId,\n          proposedVersion.minorNodeId,\n          vote.patchNodeId,\n          proposedVersion.verified,\n          proposedVersion.packageLocation\n        );\n      } else {\n        //The version is rejected\n        proposedVersion.decided = true;\n        proposedVersion.verified = false;\n\n        onVersionDecided(\n          vote.prevMinorNodeId,\n          vote.nextMinorNodeId,\n          proposedVersion.minorVersion,\n          proposedVersion.majorNodeId,\n          proposedVersion.minorNodeId,\n          vote.patchNodeId,\n          proposedVersion.verified,\n          proposedVersion.packageLocation\n        );\n      }\n\n      emit VersionVote(\n        msg.sender,\n        proposedVersion.patchNodeId,\n        keccak256(abi.encodePacked(proposedVersion.packageLocation)),\n        vote.approved\n      );\n    }\n  }\n\n  function requireCanVoteOnVersion(ProposedVersion storage proposedVersion)\n    private\n    view\n  {\n    require(proposedVersion.votingStarted, \"Voting has not started\");\n    require(!proposedVersion.decided, \"Voting for this version has ended\");\n    require(!proposedVersion.votedVerifiers[msg.sender], \"You already voted\");\n  }\n\n  function requireValidMinorVersionPlacement(\n    bytes32 prevMinorNodeId,\n    bytes32 nextMinorNodeId,\n    uint256 minorVersionNumber,\n    bytes32 majorNodeId,\n    bytes32 minorNodeId\n  ) private view {\n    VerifiedMinorVersion storage currentVersion = verifiedMinorVersions[\n      minorNodeId\n    ];\n\n    if (currentVersion.patchNodeId != 0x0) {\n      //Minor version has at least one patch version verified and there's no need to keep track of multiple patch versions\n      return;\n    }\n\n    VerifiedMinorVersion storage prevVersion = verifiedMinorVersions[\n      prevMinorNodeId\n    ];\n    VerifiedMinorVersion storage nextVersion = verifiedMinorVersions[\n      nextMinorNodeId\n    ];\n\n    //Verify the current version is between prev and next version\n    if (prevVersion.patchNodeId != 0x0) {\n      require(\n        prevVersion.versionNumber < minorVersionNumber,\n        \"Previous version number is not less than the current one\"\n      );\n      require(\n        prevVersion.nextMinorNodeId == nextMinorNodeId,\n        \"Previous version does not point to the next version\"\n      );\n      require(\n        prevVersion.majorNodeId == majorNodeId,\n        \"Previous version does not belong to the same major version\"\n      );\n    }\n\n    if (nextVersion.patchNodeId != 0x0) {\n      require(\n        minorVersionNumber < nextVersion.versionNumber,\n        \"Next version number is not greater than the current one\"\n      );\n      require(\n        nextVersion.prevMinorNodeId == prevMinorNodeId,\n        \"Next version does not point to the previous version\"\n      );\n      require(\n        nextVersion.majorNodeId == majorNodeId,\n        \"Next version does not belong to the same major version\"\n      );\n    }\n  }\n\n  function startVersionVoting(ProposedVersion storage proposedVersion) private {\n    proposedVersion.votingStarted = true;\n\n    VerifiedMinorVersion memory minorVersion = verifiedMinorVersions[\n      proposedVersion.minorNodeId\n    ];\n\n    emit VersionVotingStarted(\n      proposedVersion.packageId,\n      proposedVersion.patchNodeId,\n      proposedVersion.majorVersion,\n      proposedVersion.minorVersion,\n      proposedVersion.patchVersion,\n      proposedVersion.packageLocation,\n      proposedVersion.proposer,\n      minorVersion.patchNodeId != 0x0\n    );\n  }\n\n  function addToVersionTree(\n    bytes32 prevMinorNodeId,\n    bytes32 nextMinorNodeId,\n    uint256 minorVersionNumber,\n    bytes32 majorNodeId,\n    bytes32 minorNodeId,\n    bytes32 patchNodeId\n  ) private {\n    VerifiedMinorVersion storage currentVersion = verifiedMinorVersions[\n      minorNodeId\n    ];\n\n    currentVersion.patchNodeId = patchNodeId;\n    currentVersion.versionNumber = minorVersionNumber;\n    currentVersion.majorNodeId = majorNodeId;\n\n    VerifiedMinorVersion storage prevVersion = verifiedMinorVersions[\n      prevMinorNodeId\n    ];\n    VerifiedMinorVersion storage nextVersion = verifiedMinorVersions[\n      nextMinorNodeId\n    ];\n\n    //Insert into the linked list between prev and next version\n\n    if (prevVersion.patchNodeId != 0x0) {\n      currentVersion.prevMinorNodeId = prevMinorNodeId;\n      prevVersion.nextMinorNodeId = minorNodeId;\n    }\n\n    if (nextVersion.patchNodeId != 0x0) {\n      currentVersion.nextMinorNodeId = nextMinorNodeId;\n      nextVersion.prevMinorNodeId = minorNodeId;\n    }\n\n    if (prevVersion.patchNodeId == 0x0 && nextVersion.patchNodeId == 0x0) {}\n  }\n\n  function onVersionDecided(\n    bytes32 prevMinorNodeId,\n    bytes32 nextMinorNodeId,\n    uint256 minorVersionNumber,\n    bytes32 majorNodeId,\n    bytes32 minorNodeId,\n    bytes32 patchNodeId,\n    bool verified,\n    string memory packageLocation\n  ) private {\n    bytes32 packageLocationHash = keccak256(abi.encodePacked(packageLocation));\n\n    if (verified) {\n      addToVersionTree(\n        prevMinorNodeId,\n        nextMinorNodeId,\n        minorVersionNumber,\n        majorNodeId,\n        minorNodeId,\n        patchNodeId\n      );\n\n      if (versionVerifiedListener != address(0)) {\n        IVersionVerifiedListener listener = IVersionVerifiedListener(\n          versionVerifiedListener\n        );\n\n        listener.onVersionVerified(patchNodeId, packageLocationHash);\n      }\n    }\n\n    dequeueNextVersion(majorNodeId);\n\n    emit VersionDecided(patchNodeId, verified, packageLocationHash);\n  }\n\n  function dequeueNextVersion(bytes32 majorNodeId) private {\n    MajorVersionQueueContainer\n      storage majorVersionContainer = majorVersionQueueContainers[majorNodeId];\n\n    if (majorVersionContainer.headVersionId == 0x0) {\n      //The queue is empty\n      return;\n    }\n\n    QueuedVersion storage headVersion = majorVersionContainer.queuedVersions[\n      majorVersionContainer.headVersionId\n    ];\n\n    ProposedVersion storage nextVotingVersion = proposedVersions[\n      majorVersionContainer.headVersionId\n    ];\n\n    if (headVersion.nextQueuedVersionId == 0x0) {\n      majorVersionContainer.headVersionId = 0x0;\n      majorVersionContainer.tailVersionId = 0x0;\n    } else {\n      majorVersionContainer.headVersionId = headVersion.nextQueuedVersionId;\n    }\n\n    startVersionVoting(nextVotingVersion);\n  }\n\n  function getPrevPatchPackageLocation(bytes32 patchNodeId)\n    external\n    view\n    returns (string memory prevPackageLocation)\n  {\n    ProposedVersion storage targetVersion = proposedVersions[patchNodeId];\n\n    requireCanVoteOnVersion(targetVersion);\n\n    VerifiedMinorVersion memory minorVersion = verifiedMinorVersions[\n      targetVersion.minorNodeId\n    ];\n\n    assert(minorVersion.patchNodeId != 0x0);\n\n    string memory prevPackageLocation = proposedVersions[\n      minorVersion.patchNodeId\n    ].packageLocation;\n\n    return prevPackageLocation;\n  }\n\n  function getPrevAndNextMinorPackageLocations(bytes32 patchNodeId)\n    external\n    view\n    returns (\n      bytes32 prevMinorNodeId,\n      string memory prevPackageLocation,\n      bytes32 nextMinorNodeId,\n      string memory nextPackageLocation\n    )\n  {\n    ProposedVersion storage targetVersion = proposedVersions[patchNodeId];\n\n    requireCanVoteOnVersion(targetVersion);\n\n    VerifiedMajorVersion memory currentMajorVersion = verifiedMajorVersions[\n      targetVersion.majorNodeId\n    ];\n\n    bytes32 currentMinorNodeId = currentMajorVersion.lowestMinorNodeId;\n    bytes32 nextMinorNodeId = currentMinorNodeId;\n    bytes32 prevMinorNodeId;\n\n    VerifiedMinorVersion memory nextVersion = verifiedMinorVersions[\n      currentMinorNodeId\n    ];\n\n    VerifiedMinorVersion memory prevVersion;\n    while (nextVersion.versionNumber < targetVersion.minorVersion) {\n      prevMinorNodeId = currentMinorNodeId;\n      prevVersion = nextVersion;\n      currentMinorNodeId = nextVersion.nextMinorNodeId;\n      nextVersion = verifiedMinorVersions[currentMinorNodeId];\n    }\n\n    string memory prevPackageLocation;\n    if (prevVersion.patchNodeId != 0x0) {\n      prevPackageLocation = proposedVersions[prevVersion.patchNodeId]\n        .packageLocation;\n    }\n\n    string memory nextPackageLocation;\n    if (nextVersion.patchNodeId != 0x0) {\n      nextPackageLocation = proposedVersions[nextVersion.patchNodeId]\n        .packageLocation;\n    }\n\n    return (\n      prevMinorNodeId,\n      prevPackageLocation,\n      nextMinorNodeId,\n      nextPackageLocation\n    );\n  }\n}\n"
    },
    "contracts/versioning/bridges/token-bridge/OwnershipBridgeLink.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"../../PackageOwnershipManager.sol\";\nimport \"./ITokenBridge.sol\";\nimport \"../interfaces/IOwnershipBridgeLink.sol\";\n\ncontract OwnershipBridgeLink is IOwnershipBridgeLink, OwnableUpgradeable {\n  address public bridge;\n  address public bridgeLink;\n  address public packageOwnershipManager;\n  bytes32 public blockchainName;\n  bytes32 public bridgeChainId;\n  uint256 public relayOwnershipGasLimit;\n\n  constructor(\n    address owner,\n    address _bridge,\n    address _packageOwnershipManager,\n    bytes32 _blockchainName,\n    bytes32 _bridgeChainId,\n    uint256 _relayOwnershipGasLimit\n  ) {\n    initialize(\n      _bridge,\n      _packageOwnershipManager,\n      _blockchainName,\n      _bridgeChainId,\n      _relayOwnershipGasLimit\n    );\n    transferOwnership(owner);\n  }\n\n  function initialize(\n    address _bridge,\n    address _packageOwnershipManager,\n    bytes32 _blockchainName,\n    bytes32 _bridgeChainId,\n    uint256 _relayOwnershipGasLimit\n  ) public initializer {\n    __Ownable_init();\n\n    bridge = _bridge;\n    packageOwnershipManager = _packageOwnershipManager;\n    blockchainName = _blockchainName;\n    bridgeChainId = _bridgeChainId;\n    relayOwnershipGasLimit = _relayOwnershipGasLimit;\n  }\n\n  function updateBridge(address _bridge) public onlyOwner {\n    bridge = _bridge;\n  }\n\n  function updateBridgeLink(address _bridgeLink) public onlyOwner {\n    bridgeLink = _bridgeLink;\n  }\n\n  function updatePackageOwnershipManager(address _packageOwnershipManager)\n    public\n    onlyOwner\n  {\n    packageOwnershipManager = _packageOwnershipManager;\n  }\n\n  function updateBlockchainName(bytes32 _blockchainName) public onlyOwner {\n    blockchainName = _blockchainName;\n  }\n\n  function updateBridgeChainId(bytes32 _bridgeChainId) public onlyOwner {\n    bridgeChainId = _bridgeChainId;\n  }\n\n  function updateRelayOwnershipGasLimit(uint256 _relayOwnershipGasLimit)\n    public\n    onlyOwner\n  {\n    relayOwnershipGasLimit = _relayOwnershipGasLimit;\n  }\n\n  function relayOwnership(\n    bytes32 domainRegistrar,\n    bytes32 domainRegistrarNode,\n    address owner\n  ) public virtual override {\n    assert(msg.sender == packageOwnershipManager);\n\n    bytes4 methodSelector = IOwnershipBridgeLink(address(0))\n      .receiveOwnership\n      .selector;\n    bytes memory data = abi.encodeWithSelector(\n      methodSelector,\n      domainRegistrar,\n      domainRegistrarNode,\n      owner\n    );\n    ITokenBridge(bridge).requireToPassMessage(\n      bridgeLink,\n      data,\n      relayOwnershipGasLimit\n    );\n  }\n\n  function receiveOwnership(\n    bytes32 domainRegistrar,\n    bytes32 domainRegistrarNode,\n    address owner\n  ) public virtual override {\n    assert(msg.sender == bridge);\n\n    ITokenBridge bridgeContract = ITokenBridge(bridge);\n    assert(bridgeContract.messageSender() == bridgeLink);\n    assert(bridgeContract.messageSourceChainId() == bridgeChainId);\n\n    PackageOwnershipManager(packageOwnershipManager).receiveOwnership(\n      blockchainName,\n      domainRegistrar,\n      domainRegistrarNode,\n      owner\n    );\n  }\n}\n"
    },
    "contracts/versioning/bridges/token-bridge/mocks/VerificationRootBridgeLinkMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../../../VersionVerificationManager.sol\";\nimport \"../../../PackageOwnershipManager.sol\";\nimport \"../ITokenBridge.sol\";\nimport \"../VerificationRootBridgeLink.sol\";\nimport \"../../interfaces/IVerificationRootBridgeLink.sol\";\n\ncontract VerificationRootBridgeLinkMock is VerificationRootBridgeLink {\n  constructor(\n    address owner,\n    address _bridge,\n    bytes32 _bridgeChainId,\n    uint256 _relayVerificationRootGasLimit\n  )\n    VerificationRootBridgeLink(\n      owner,\n      _bridge,\n      _bridgeChainId,\n      _relayVerificationRootGasLimit\n    )\n  {}\n\n  function relayVerificationRoot(bytes32 verificationRoot) public override {\n    assert(msg.sender == verificationRootRelayer);\n\n    IVerificationRootBridgeLink(bridgeLink).receiveVerificationRoot(\n      verificationRoot\n    );\n  }\n\n  function receiveVerificationRoot(bytes32 verificationRoot) public override {\n    assert(msg.sender == bridgeLink);\n\n    VersionVerificationManager(versionVerificationManager)\n      .updateVerificationRoot(verificationRoot);\n  }\n}\n"
    },
    "contracts/versioning/bridges/token-bridge/mocks/OwnershipBridgeLinkMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../../../PackageOwnershipManager.sol\";\nimport \"../ITokenBridge.sol\";\nimport \"../OwnershipBridgeLink.sol\";\n\ncontract OwnershipBridgeLinkMock is OwnershipBridgeLink {\n  constructor(\n    address owner,\n    address _bridge,\n    address _packageOwnershipManager,\n    bytes32 _blockchainName,\n    bytes32 _bridgeChainId,\n    uint256 _relayOwnershipGasLimit\n  )\n    OwnershipBridgeLink(\n      owner,\n      _bridge,\n      _packageOwnershipManager,\n      _blockchainName,\n      _bridgeChainId,\n      _relayOwnershipGasLimit\n    )\n  {}\n\n  function relayOwnership(\n    bytes32 domainRegistrar,\n    bytes32 domainRegistrarNode,\n    address owner\n  ) public virtual override {\n    assert(msg.sender == packageOwnershipManager);\n\n    OwnershipBridgeLink(bridgeLink).receiveOwnership(\n      domainRegistrar,\n      domainRegistrarNode,\n      owner\n    );\n  }\n\n  function receiveOwnership(\n    bytes32 domainRegistrar,\n    bytes32 domainRegistrarNode,\n    address owner\n  ) public virtual override {\n    assert(msg.sender == bridgeLink);\n\n    PackageOwnershipManager(packageOwnershipManager).receiveOwnership(\n      blockchainName,\n      domainRegistrar,\n      domainRegistrarNode,\n      owner\n    );\n  }\n}\n"
    },
    "contracts/versioning/registrar/PolywrapRegistrar.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./Registrar.sol\";\n\ncontract PolywrapRegistrar is Registrar {\n  constructor(address owner, address _registry) Registrar(owner, _registry) {}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}